import {
  AfterContentChecked, AfterContentInit, Attribute, ChangeDetectorRef,
  ContentChildren,
  Directive, ElementRef,
  EventEmitter, forwardRef,
  Inject, Injectable,
  Input, OnChanges, OnDestroy,
  OnInit,
  Output,
  QueryList, SimpleChanges,
  TemplateRef
} from '@angular/core';
import {Subject} from 'rxjs';
import {DOCUMENT} from '@angular/common';
import {Key} from '../../../../../src/util/key';
import {takeUntil} from 'rxjs/operators';

export function isDefined(value: any): boolean {
  return value !== undefined && value !== null;
}

const isValidNavId = (id: any) => isDefined(id) && id !== '';

let navCounter = 0;

@Injectable({providedIn: 'root'})
export class NthdConfig {
}

@Injectable({providedIn: 'root'})
export class NthdNavConfig {
  destroyOnHide = true;
  orientation: 'horizontal' | 'vertical' = 'horizontal';
  roles: 'tablist' | false = 'tablist';
  keyboard: boolean | 'changeWithArrows' = false;

  constructor(private _ngbConfig: NthdConfig) {}
}

export interface NthdNavContentContext {
  /**
   * If `true`, current nav content is visible and active
   */
  $implicit: boolean;
}

@Directive({selector: 'ng-template[nthdNavContent]'})
export class NthdNavContent {
  constructor(public templateRef: TemplateRef<any>) {}
}

@Directive({selector: '[nthdNavItem]', exportAs: 'nthdNavItem', host: {'[class.nav-item]': 'true'}})
export class NthdNavItem implements AfterContentChecked, OnInit {
  /**
   * If `true`, non-active current nav item content will be removed from DOM
   * Otherwise it will just be hidden
   */
  @Input() destroyOnHide;

  /**
   * If `true`, the current nav item is disabled and can't be toggled by user.
   *
   * Nevertheless disabled nav can be selected programmatically via the `.select()` method and the `[activeId]` binding.
   */
  @Input() disabled = false;

  /**
   * The id used for the DOM elements.
   * Must be unique inside the document in case you have multiple `nthdNav`s on the page.
   *
   * Autogenerated as `nthd-nav-XXX` if not provided.
   */
  @Input() domId: string;

  /**
   * The id used as a model for active nav.
   * It can be anything, but must be unique inside one `nthdNav`.
   *
   * The only limitation is that it is not possible to have the `''` (empty string) as id,
   * because ` nthdNavItem `, `nthdNavItem=''` and `[nthdNavItem]="''"` are indistinguishable
   */
  @Input('nthdNavItem') _id: any;

  /**
   * An event emitted when the fade in transition is finished on the related nav content
   *
   * @since 8.0.0
   */
  @Output() shown = new EventEmitter<void>();

  /**
   * An event emitted when the fade out transition is finished on the related nav content
   *
   * @since 8.0.0
   */
  @Output() hidden = new EventEmitter<void>();

  contentTpl: NthdNavContent | null;

  @ContentChildren(NthdNavContent, {descendants: false}) contentTpls: QueryList<NthdNavContent>;

  constructor(@Inject(forwardRef(() => NthdNav)) private _nav: NthdNav, public elementRef: ElementRef<any>) {}

  ngAfterContentChecked() {
    // We are using @ContentChildren instead of @ContentChild as in the Angular version being used
    // only @ContentChildren allows us to specify the {descendants: false} option.
    // Without {descendants: false} we are hitting bugs described in:
    // https://github.com/ng-bootstrap/ng-bootstrap/issues/2240
    this.contentTpl = this.contentTpls.first;
  }

  ngOnInit() {
    if (!isDefined(this.domId)) {
      this.domId = `nthd-nav-${navCounter++}`;
    }
  }

  get active() { return this._nav.activeId === this.id; }

  get id() { return isValidNavId(this._id) ? this._id : this.domId; }

  get panelDomId() { return `${this.domId}-panel`; }

  isPanelInDom() {
    return (isDefined(this.destroyOnHide) ? !this.destroyOnHide : !this._nav.destroyOnHide) || this.active;
  }
}

@Directive({
  selector: '[nthdNav]',
  exportAs: 'nthdNav',
  host: {
    '[class.nav]': 'true',
    '[class.flex-column]': `orientation === 'vertical'`,
    '[attr.aria-orientation]': `orientation === 'vertical' && roles === 'tablist' ? 'vertical' : undefined`,
    '[attr.role]': `role ? role : roles ? 'tablist' : undefined`,
    '(keydown.arrowLeft)': 'onKeyDown($event)',
    '(keydown.arrowRight)': 'onKeyDown($event)',
    '(keydown.arrowDown)': 'onKeyDown($event)',
    '(keydown.arrowUp)': 'onKeyDown($event)',
    '(keydown.Home)': 'onKeyDown($event)',
    '(keydown.End)': 'onKeyDown($event)'
  }
})
export class NthdNav implements AfterContentInit,
  OnChanges, OnDestroy {
  static ngAcceptInputType_orientation: string;
  static ngAcceptInputType_roles: boolean | string;

  /**
   * The id of the nav that should be active
   *
   * You could also use the `.select()` method and the `(navChange)` event
   */
  @Input() activeId: any;

  /**
   * The event emitted after the active nav changes
   * The payload of the event is the newly active nav id
   *
   * If you want to prevent nav change, you should use `(navChange)` event
   */
  @Output() activeIdChange = new EventEmitter<any>();

  /**
   * If `true`, nav change will be animated.
   *
   * @since 8.0.0
   */
  @Input() animation: boolean;

  /**
   * If `true`, non-active nav content will be removed from DOM
   * Otherwise it will just be hidden
   */
  @Input() destroyOnHide;

  /**
   * The orientation of navs.
   *
   * Using `vertical` will also add the `aria-orientation` attribute
   */
  @Input() orientation: 'horizontal' | 'vertical';

  /**
   * Role attribute generating strategy:
   * - `false` - no role attributes will be generated
   * - `'tablist'` - 'tablist', 'tab' and 'tabpanel' will be generated (default)
   */
  @Input() roles: 'tablist' | false;

  /**
   * Keyboard support for nav focus/selection using arrow keys.
   *
   * * `false` - no keyboard support.
   * * `true` - navs will be focused using keyboard arrow keys
   * * `'changeWithArrows'` -  nav will be selected using keyboard arrow keys
   *
   * See the [list of available keyboard shortcuts](#/components/nav/overview#keyboard-shortcuts).
   *
   * @since 6.1.0
   */
  @Input() keyboard: boolean | 'changeWithArrows';

  /**
   * An event emitted when the fade in transition is finished for one of the items.
   *
   * Payload of the event is the nav id that was just shown.
   */
  @Output() shown = new EventEmitter<any>();

  /**
   * An event emitted when the fade out transition is finished for one of the items.
   *
   * Payload of the event is the nav id that was just hidden.
   */
  @Output() hidden = new EventEmitter<any>();

  @ContentChildren(NthdNavItem) items: QueryList<NthdNavItem>;
  @ContentChildren(forwardRef(() => NthdNavLink), {descendants: true}) links: QueryList<NthdNavLink>;

  destroy$ = new Subject<void>();
  navItemChange$ = new Subject<NthdNavItem | null>();

  constructor(
    @Attribute('role') public role: string, config: NthdNavConfig, private _cd: ChangeDetectorRef,
    @Inject(DOCUMENT) private _document: any) {
    this.animation = true;
    this.destroyOnHide = config.destroyOnHide;
    this.orientation = config.orientation;
    this.roles = config.roles;
    this.keyboard = config.keyboard;
  }

  /**
   * The nav change event emitted right before the nav change happens on user click.
   *
   * This event won't be emitted if nav is changed programmatically via `[activeId]` or `.select()`.
   *
   * See [`NthdNavChangeEvent`](#/components/nav/api#NthdNavChangeEvent) for payload details.
   */
  @Output() navChange = new EventEmitter<NthdNavChangeEvent>();

  click(item: NthdNavItem) {
    if (!item.disabled) {
      this._updateActiveId(item.id);
    }
  }

  onKeyDown(event: KeyboardEvent) {
    if (this.roles !== 'tablist' || !this.keyboard) {
      return;
    }
    /* eslint-disable-next-line deprecation/deprecation */
    const key = event.which;
    const enabledLinks = this.links.filter(link => !link.navItem.disabled);
    const {length} = enabledLinks;

    let position = -1;

    enabledLinks.forEach((link, index) => {
      if (link.elRef.nativeElement === this._document.activeElement) {
        position = index;
      }
    });

    if (length) {
      switch (key) {
        case Key.ArrowLeft:
          if (this.orientation === 'vertical') {
            return;
          }
          position = (position - 1 + length) % length;
          break;
        case Key.ArrowRight:
          if (this.orientation === 'vertical') {
            return;
          }
          position = (position + 1) % length;
          break;
        case Key.ArrowDown:
          if (this.orientation === 'horizontal') {
            return;
          }
          position = (position + 1) % length;
          break;
        case Key.ArrowUp:
          if (this.orientation === 'horizontal') {
            return;
          }
          position = (position - 1 + length) % length;
          break;
        case Key.Home:
          position = 0;
          break;
        case Key.End:
          position = length - 1;
          break;
      }
      if (this.keyboard === 'changeWithArrows') {
        this.select(enabledLinks[position].navItem.id);
      }
      enabledLinks[position].elRef.nativeElement.focus();

      event.preventDefault();
    }
  }

  /**
   * Selects the nav with the given id and shows its associated pane.
   * Any other nav that was previously selected becomes unselected and its associated pane is hidden.
   */
  select(id: any) { this._updateActiveId(id, false); }

  ngAfterContentInit() {
    if (!isDefined(this.activeId)) {
      const nextId = this.items.first ? this.items.first.id : null;
      if (isValidNavId(nextId)) {
        this._updateActiveId(nextId, false);
        this._cd.detectChanges();
      }
    }

    this.items.changes.pipe(takeUntil(this.destroy$)).subscribe(() => this._notifyItemChanged(this.activeId));
  }

  ngOnChanges({activeId}: SimpleChanges): void {
    if (activeId && !activeId.firstChange) {
      this._notifyItemChanged(activeId.currentValue);
    }
  }

  ngOnDestroy() { this.destroy$.next(); }

  private _updateActiveId(nextId: any, emitNavChange = true) {
    if (this.activeId !== nextId) {
      let defaultPrevented = false;

      if (emitNavChange) {
        this.navChange.emit({activeId: this.activeId, nextId, preventDefault: () => { defaultPrevented = true; }});
      }

      if (!defaultPrevented) {
        this.activeId = nextId;
        this.activeIdChange.emit(nextId);
        this._notifyItemChanged(nextId);
      }
    }
  }

  private _notifyItemChanged(nextItemId: any) { this.navItemChange$.next(this._getItemById(nextItemId)); }

  private _getItemById(itemId: any): NthdNavItem | null {
    return this.items && this.items.find(item => item.id === itemId) || null;
  }
}

@Directive({
  selector: 'a[nthdNavLink]',
  host: {
    '[id]': 'navItem.domId',
    '[class.nav-link]': 'true',
    '[class.nav-item]': 'hasNavItemClass()',
    '[attr.role]': `role ? role : nav.roles ? 'tab' : undefined`,
    'href': '',
    '[class.active]': 'navItem.active',
    '[class.disabled]': 'navItem.disabled',
    '[attr.tabindex]': 'navItem.disabled ? -1 : undefined',
    '[attr.aria-controls]': 'navItem.isPanelInDom() ? navItem.panelDomId : null',
    '[attr.aria-selected]': 'navItem.active',
    '[attr.aria-disabled]': 'navItem.disabled',
    '(click)': 'nav.click(navItem); $event.preventDefault()'
  }
})
export class NthdNavLink {
  constructor(
    @Attribute('role') public role: string, public navItem: NthdNavItem, public nav: NthdNav,
    public elRef: ElementRef) {}

  hasNavItemClass() {
    // with alternative markup we have to add `.nav-item` class, because `nthdNavItem` is on the ng-container
    return this.navItem.elementRef.nativeElement.nodeType === Node.COMMENT_NODE;
  }
}

export interface NthdNavChangeEvent<T = any> {
  /**
   * Id of the currently active nav.
   */
  activeId: T;

  /**
   * Id of the newly selected nav.
   */
  nextId: T;

  /**
   * Function that will prevent nav change if called.
   */
  preventDefault: () => void;
}
